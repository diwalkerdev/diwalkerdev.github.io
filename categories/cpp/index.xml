<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cpp on </title>
    <link>https://example.org/categories/cpp/</link>
    <description>Recent content in cpp on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© {year}</copyright>
    <lastBuildDate>Thu, 13 Jun 2019 10:00:30 +0100</lastBuildDate>
    
	<atom:link href="https://example.org/categories/cpp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Building C&#43;&#43; (Part 4) - Include directories</title>
      <link>https://example.org/c&#43;&#43;/2019-06-13-include-directories/</link>
      <pubDate>Thu, 13 Jun 2019 10:00:30 +0100</pubDate>
      
      <guid>https://example.org/c&#43;&#43;/2019-06-13-include-directories/</guid>
      <description>Building C++ (part 4) - include directories Last time we covered include files and some common errors associated with them. I now want to cover include directories, which is the final piece of information needed before we can cover the topic of libraries.
First some house keeping, create an include directory and then move calculator.h into it. Also add a new build file: .includes.
├───build │ └───pc-clang │ .cxxflags │ .</description>
    </item>
    
    <item>
      <title>Building C&#43;&#43; (Part 3) - Header files</title>
      <link>https://example.org/c&#43;&#43;/2019-06-07-header_files/</link>
      <pubDate>Fri, 07 Jun 2019 14:30:30 +0100</pubDate>
      
      <guid>https://example.org/c&#43;&#43;/2019-06-07-header_files/</guid>
      <description>Building C++ (part 3) - Header files Last time we split the build process into a compile and link step. This is important when using libraries, but before we can address libraries we need to look at header files and include paths.
Preprocessing I also mentioned that there are more steps than compiling and linking. The first step that actually happens is preprocessing. The preprocessor changes the source code based on instructions within the source code and symbols passed to the compiler.</description>
    </item>
    
    <item>
      <title>Building C&#43;&#43; (Part 2) - Basics</title>
      <link>https://example.org/c&#43;&#43;/2019-06-04-building-cpp-basics/</link>
      <pubDate>Tue, 04 Jun 2019 15:39:30 +0100</pubDate>
      
      <guid>https://example.org/c&#43;&#43;/2019-06-04-building-cpp-basics/</guid>
      <description>Building C++ (Part 2) - Basics In part 1 we installed Clang, setup a simple project structure and created a build script to build our code. Now we will look into the build process in a bit more detail.
Compiling Begin by adding a compilation function to the build script:
def compilation(msg, cxxflags, files): result = subprocess.run([&amp;quot;clang++ -c&amp;quot;] + cxxflags + files, capture_output=True) print(result) if result.returncode != 0: print(msg + &amp;quot;Compilation Failed!</description>
    </item>
    
    <item>
      <title>Building C&#43;&#43; (Part 1) - Introduction</title>
      <link>https://example.org/c&#43;&#43;/2019-06-03-building-cpp-intro/</link>
      <pubDate>Mon, 03 Jun 2019 16:31:30 +0100</pubDate>
      
      <guid>https://example.org/c&#43;&#43;/2019-06-03-building-cpp-intro/</guid>
      <description>Building C++ (Part 1) - Introduction In this series I would like to explain how to build C++ projects.
We&amp;rsquo;ll cover:
 The basics of building and structuring projects. The difference in building executables, static libraries and dynamic libraries. How to link against 3rd party libraries. Building for different targets.  By the end of the series you will also develop an understanding and appreciation of what make C++ hard to build.</description>
    </item>
    
  </channel>
</rss>